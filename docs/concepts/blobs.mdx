---
title: "Blobs"
description: "content addressing and binary data in atproto"
---

# blobs in atproto

## what are blobs?

blobs (binary large objects) are how atproto handles non-text data - images, videos, audio, documents. unlike records (json), blobs are opaque binary data referenced by records.

## content addressing

atproto uses **content addressing** for blobs - data is identified by its content hash, not location.

### traditional location-based storage
```
https://cdn.example.com/users/alice/photo.jpg
└─ location determines identity
```

problems:
- link breaks if file moves
- can't verify content hasn't changed
- duplication if same file uploaded multiple times

### content-addressed storage (atproto)
```
bafkreif4oxjpqppiy6qvxpmgk7dv2sgxh6kanc5e5aztvgqvqho2q34c5u
└─ content hash determines identity
```

benefits:
- same content = same identifier (deduplication)
- can verify integrity (hash the data, compare to id)
- immutable - changing content changes id
- location-independent

## cid (content identifier)

atproto uses **cid** (content identifier) from ipfs/ipld:

```
bafkreif4oxjpqppiy6qvxpmgk7dv2sgxh6kanc5e5aztvgqvqho2q34c5u
└─┬─┘ └──────────────────────────────────────────────┘
  │                    multihash (sha-256)
  └─ multibase prefix (base32)
```

### components

**multibase**: encoding format (base32, base64, etc)
- `bafkrei...` = base32
- allows future encoding changes

**multihash**: cryptographic hash
- sha-256 by default
- includes hash algorithm identifier
- allows future algorithm changes

### immutability

cids are immutable by design:
- change one byte → completely different cid
- can't "update" a blob, only upload new one
- guarantees integrity (tamper-evident)

## blob lifecycle

### 1. upload (temporary storage)

```
client uploads bytes → server computes cid → temporary storage
```

temporary blobs:
- stored for ~1 hour
- not accessible via public url
- will be garbage collected if not referenced

**why temporary?** prevents spam - server doesn't commit resources until blob is actually used.

### 2. reference in record

```
create/update record → record references blob cid → blob promoted to permanent
```

once a record references the blob:
- blob moves to permanent storage
- becomes accessible via cdn/url
- protected from garbage collection

### 3. garbage collection

blobs are deleted when:
- temporary and unreferenced after timeout
- no records reference them anymore
- parent record deleted

**reference counting**: server tracks which records reference each blob. when ref count hits zero, blob is eligible for gc.

## blob references in records

blobs are embedded in records via **blob references**:

```json
{
  "$type": "blob",
  "ref": {
    "$link": "bafkreif4oxjpqppiy6qvxpmgk7dv2sgxh6kanc5e5aztvgqvqho2q34c5u"
  },
  "mimeType": "image/jpeg",
  "size": 49004
}
```

### fields

**$type**: identifies this as a blob reference (not the blob data itself)

**ref.$link**: the cid (content identifier) - points to the actual blob data

**mimeType**: content type for rendering
- server-validated on upload
- used by clients for display decisions

**size**: bytes
- for client storage/bandwidth planning
- validated on upload against size limits

## deduplication

content addressing enables automatic deduplication:

```
user A uploads cat.jpg → cid: bafkrei123...
user B uploads same cat.jpg → cid: bafkrei123... (identical!)
```

server can:
- detect duplicate (same cid)
- reuse existing storage
- only store once, reference multiple times

benefits:
- reduced storage costs
- faster uploads (check before transferring)
- bandwidth savings

## size limits

blobs have size constraints that vary by:
- pds instance policies
- blob mime type
- user account tier

typical limits:
- images: 1mb
- videos: 50mb (varies widely)
- total user storage quotas

**why limits?** prevents resource exhaustion on pds instances. atproto is federated - each pds sets own policies.

## mime type validation

servers validate mime types to prevent abuse:

```
upload video/mp4 → check magic bytes → verify matches declared mime type
```

validation prevents:
- serving malicious content disguised as images
- mime type confusion attacks
- incorrect client rendering

**magic bytes**: file format signatures embedded in data. server reads these to verify actual format matches declared mime type.

## access patterns

### direct access
blobs can be fetched by cid:
```
GET https://pds.example.com/xrpc/com.atproto.sync.getBlob?cid=bafkrei...
```

### cdn distribution
pds instances may use cdns for blob delivery:
- geographically distributed
- cached at edge
- reduced pds load

### authentication
blob access typically requires:
- public blobs: no auth
- private blobs: requires valid did auth

## design tradeoffs

### immutability vs updates
content addressing means blobs can't be "edited":

**advantage**: integrity guarantees - what you reference is what you get

**disadvantage**: updating requires:
1. upload new blob → new cid
2. update record reference → point to new cid
3. old blob garbage collected

### storage vs bandwidth
deduplication saves storage but requires:
- hash computation on upload
- lookup before storing
- slightly slower upload path

**tradeoff**: atproto chooses storage efficiency over upload speed.

### temporary storage overhead
temporary blobs create gc overhead:

**advantage**: prevents spam, only commit after use

**disadvantage**: server must track timeouts, run gc

**tradeoff**: atproto chooses spam prevention over simplicity.

## distribution model

### pds-centric storage
blobs live on the pds that hosts the repository:
```
alice@pds1.com uploads blob → stored on pds1.com
bob@pds2.com uploads blob → stored on pds2.com (even if same content!)
```

**no cross-pds deduplication** - each pds manages own blobs independently.

**why?** simplifies federation - no shared storage to coordinate.

### relay distribution
relays may cache blobs for performance but don't own them:
```
pds1 → relay (cache) → clients
```

## security considerations

### content validation
servers must validate:
- actual format matches declared mime type
- size within limits
- no malicious payloads (script injection, etc)

### access control
blob references in public records make blobs public. for private content:
- store in private records
- access requires auth
- pds enforces permissions

### immutability guarantees
cids provide tamper-evidence:
```
record says: image is bafkrei123...
fetch bafkrei123... → hash content → verify matches cid
```

if hash doesn't match, content was tampered with.

## atproto-specific details

### blob sync protocol
atproto defines blob sync alongside record sync:
- `com.atproto.sync.getBlob` - fetch by cid
- `com.atproto.sync.listBlobs` - list repo's blobs
- supports federated backup/migration

### lexicon integration
lexicons define which record types can contain blobs:
- `app.bsky.embed.images` - post images
- `app.bsky.actor.profile` - avatar/banner
- `app.bsky.embed.video` - video embeds (future)

### repo commits
blob references are part of repo state:
- included in merkle trees
- verified on sync
- part of cryptographic audit trail

## design philosophy

blob handling reflects atproto's principles:

**1. content addressing over location**: data identified by what it is, not where it is

**2. immutability**: guarantees about data integrity

**3. federation-friendly**: each pds manages own storage, no shared dependencies

**4. spam prevention**: temporary storage + garbage collection

**5. user sovereignty**: users can migrate blobs with their repositories

## further reading

- [content addressing](https://en.wikipedia.org/wiki/Content-addressable_storage)
- [cid specification](https://github.com/multiformats/cid)
- [atproto blob spec](https://atproto.com/specs/blob)
- [multihash](https://multiformats.io/multihash/)
